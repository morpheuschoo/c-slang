/**
 * C AST Processor Module.
 */

import { CAstRoot } from "~src/parser/c-ast/core";
import { CAstRootP } from "~src/processor/c-ast/core";
import processFunctionDefinition from "~src/processor/processFunctionDefinition";
import { processGlobalScopeDeclaration } from "~src/processor/processDeclaration";
import { SymbolTable } from "~src/processor/symbolTable";
import ModuleRepository, { ModuleName } from "~src/modules";
import { ProcessingError } from "~src/errors";
import { Warning, clearWarnings, warnings } from "~src/processor/warningUtil";
import { resetProcessorAuxInfo } from "~src/processor/processBlockItem";
import { memoryManager } from "~src/processor/memoryManager";

/**
 * Processes the C AST tree generated by parsing, to add additional needed information for certain nodes.
 * @param ast
 * @param sourceCode
 * @returns { astRootNode: root node of processed C AST, includedModules: list of all modules included in the C program}
 */
export default function process(
  ast: CAstRoot,
  moduleRepository: ModuleRepository
): {
  astRootNode: CAstRootP;
  includedModules: ModuleName[];
  warnings: Warning[];
} {
  clearWarnings();
  const includedModules: ModuleName[] = [];
  const symbolTable = new SymbolTable();
  const processedExternalFunctions = symbolTable.setExternalFunctions(
    ast.includedModules,
    moduleRepository
  );
  const processedAst: CAstRootP = {
    type: "Root",
    functions: [],
    dataSegmentByteStr: "",
    dataSegmentSizeInBytes: 0,
    externalFunctions: [],
    functionTable: [],
    position: ast.position,
  };

  // save the processed details of external functions
  for (const moduleName of ast.includedModules) {
    includedModules.push(moduleName);
    Object.keys(moduleRepository.modules[moduleName].moduleFunctions).forEach(
      (moduleFunctionName) => {
        processedAst.externalFunctions.push({
          moduleName,
          name: moduleFunctionName,
          parameters:
            processedExternalFunctions[moduleFunctionName].functionDetails
              .parameters,
          returnObjects:
            processedExternalFunctions[moduleFunctionName].functionDetails
              .returnObjects,
        });
      }
    );
  }
  ast.children.forEach((child) => {
    // special handling for function definitions
    resetProcessorAuxInfo();
    if (child.type === "FunctionDefinition") {
      processedAst.functions.push(
        processFunctionDefinition(child, symbolTable)
      );
    } else {
      processGlobalScopeDeclaration(child, symbolTable);
    }
  });

  // check for presence of main function
  if (!symbolTable.hasSymbol("main")) {
    throw new ProcessingError("main function not defined");
  }

  debugPrintMemoryMap(); // Add this function call

  processedAst.dataSegmentByteStr = symbolTable.dataSegmentByteStr.value;
  processedAst.dataSegmentSizeInBytes = symbolTable.dataSegmentOffset.value;
  processedAst.functionTable = symbolTable.functionTable;
  return { astRootNode: processedAst, includedModules, warnings };
}

function debugPrintMemoryMap(): void {
  console.log("\n=== MEMORY ADDRESS MAP ===");
  console.log("Variable Name         | Scope           | Offset | Size");
  console.log("----------------------------------------------------");

  const addressMap = memoryManager.getAddressMap();
  const map = addressMap.getAddressMap();

  // Group entries by scope for better organization
  const globalEntries: Array<[string, any]> = [];
  const localEntriesByFunction: Record<string, Array<[string, any]>> = {};

  map.forEach((entry, name) => {
    // Check if this is a scoped name (contains a dot)
    // const scopeMatch = name.name.match(/^(.+)\.(.+)$/);

    if (entry.isGlobal) {
      globalEntries.push([name.name, entry]);
    } else if (name.name && name.scope) {
      const functionName = name.scope;
      const varName = name.name;

      if (!localEntriesByFunction[functionName]) {
        localEntriesByFunction[functionName] = [];
      }

      // Store with the real variable name (without scope prefix)
      localEntriesByFunction[functionName].push([varName, entry]);
    } else {
      // Local variable without proper scope - fallback
      if (!localEntriesByFunction["unknown"]) {
        localEntriesByFunction["unknown"] = [];
      }
      localEntriesByFunction["unknown"].push([name.name, entry]);
    }
  });

  // Print all variables in a flat list but with their scope displayed
  const allEntries: Array<[string, string, any]> = [];

  // Add global variables
  globalEntries.forEach(([name, entry]) => {
    allEntries.push([name, "global", entry]);
  });

  // Add local variables with their function name as scope
  Object.entries(localEntriesByFunction).forEach(([functionName, entries]) => {
    entries.forEach(([name, entry]) => {
      allEntries.push([name, functionName, entry]);
    });
  });

  // Sort by scope and then by offset
  allEntries.sort((a, b) => {
    if (a[1] !== b[1]) {
      // Sort global scope first
      if (a[1] === "global") return -1;
      if (b[1] === "global") return 1;
      // Then alphabetically by function name
      return a[1].localeCompare(b[1]);
    }
    // Within same scope, sort by offset
    return a[2].offset - b[2].offset;
  });

  // Print the sorted entries
  allEntries.forEach(([name, scope, entry]) => {
    console.log(
      `${name.padEnd(20)} | ${scope.padEnd(15)} | ` +
        `${entry.offset.toString().padEnd(6)} | ${entry.size} bytes`
    );
  });

  console.log("=============================================\n");
}
